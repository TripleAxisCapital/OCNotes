<!DOCTYPE html>
<html lang="en" class="h-full" data-theme="dark">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>OC Notes â€” Hybrid Word Ã— Obsidian (Single-File)</title>
  <meta name="description" content="Apple-style hybrid note app: rich document editor (Letter page) + freeform canvas with drawing. Export DOCX/PDF/HTML. Recent history. Dark/Light." />
  <meta name="theme-color" content="#0b0b0b" media="(prefers-color-scheme: dark)">
  <meta name="theme-color" content="#f5f5f7" media="(prefers-color-scheme: light)">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <link rel="manifest" href="manifest.webmanifest" crossorigin="use-credentials">

  <!-- TailwindCSS (CDN) -->
  <script> window.tailwind = { config: { darkMode: 'class' } } </script>
  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    tailwind.config = {
      darkMode: 'class',
      theme: {
        extend: {
          colors: { oc: { accent: '#3B82F6' } },
          borderRadius: { '2.5xl': '1.25rem' },
          boxShadow: {
            glass: '0 1px 0 rgba(255,255,255,0.06) inset, 0 20px 60px rgba(0,0,0,0.35)',
            paper: '0 10px 30px rgba(0,0,0,0.18)'
          },
          fontFamily: {
            system: [
              'ui-sans-serif','SF Pro Text','-apple-system','BlinkMacSystemFont',
              'Segoe UI','Roboto','Helvetica Neue','Arial','Noto Sans',
              'Apple Color Emoji','Segoe UI Emoji','Segoe UI Symbol'
            ]
          }
        }
      }
    }
  </script>

  <!-- Quill (rich text) -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/quill@1.3.7/dist/quill.snow.css" />
  <script src="https://cdn.jsdelivr.net/npm/quill@1.3.7/dist/quill.min.js"></script>

  <!-- Fabric.js (canvas) -->
  <script src="https://cdn.jsdelivr.net/npm/fabric@5.3.0/dist/fabric.min.js"></script>

  <!-- Export libs -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html-docx-js/0.4.1/html-docx.js"></script>

  <style>
    :root {
      --bg:#0b0b0b; --text:#ededed; --muted:rgba(255,255,255,0.7);
      --panel:rgba(255,255,255,0.06); --panel-2:rgba(255,255,255,0.04);
      --line:rgba(255,255,255,0.12); --accent:#3B82F6;
      --shadow-paper:0 10px 30px rgba(0,0,0,0.18);
      --paper:#111214; --paper-text:#f2f2f2; --paper-edge:rgba(255,255,255,0.06);
    }
    html[data-theme="light"]{
      --bg:#f5f5f7; --text:#0a0a0a; --muted:rgba(0,0,0,0.65);
      --panel:rgba(255,255,255,0.9); --panel-2:rgba(255,255,255,0.85);
      --line:rgba(0,0,0,0.08); --accent:#0A84FF;
      --paper:#ffffff; --paper-text:#0a0a0a; --paper-edge:rgba(0,0,0,0.08);
    }
    html,body{height:100%}
    body{
      background:var(--bg); color:var(--text);
      font-family:ui-sans-serif, SF Pro Text, -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Helvetica Neue, Arial, Noto Sans, Apple Color Emoji, Segoe UI Emoji, Segoe UI Symbol;
    }
    .glass{background:var(--panel); backdrop-filter:blur(12px)}
    .glass-2{background:var(--panel-2); backdrop-filter:blur(12px)}
    .grad-bg{
      background:
        radial-gradient(1200px 600px at 20% 10%, rgba(99,102,241,0.20), transparent 60%),
        radial-gradient(1200px 800px at 80% 20%, rgba(56,189,248,0.15), transparent 60%),
        radial-gradient(1000px 1000px at 50% 100%, rgba(236,72,153,0.10), transparent 60%);
      animation:breathe 12s ease-in-out infinite;
    }
    @keyframes breathe{0%,100%{filter:saturate(100%) brightness(100%)}50%{filter:saturate(120%) brightness(112%)}}
    ::-webkit-scrollbar{width:10px;height:10px}
    ::-webkit-scrollbar-thumb{background:var(--line);border-radius:999px}
    ::-webkit-scrollbar-track{background:var(--panel-2)}
    .ql-toolbar.ql-snow{border:1px solid var(--line);background:var(--panel-2);color:var(--text); position:relative; z-index:60; overflow:visible}
    .ql-toolbar .ql-picker,.ql-toolbar button{color:var(--text)}
    .ql-snow .ql-stroke{stroke:var(--text)} .ql-snow .ql-fill{fill:var(--text)}
    .ql-container.ql-snow{border:1px solid var(--line);background:transparent;color:var(--text)}
    .ql-editor{color:var(--paper-text)}
    /* Clear, visible selection in both themes */
    html[data-theme="dark"] ::selection{ background: rgba(59,130,246,0.35); color: inherit }
    html[data-theme="light"] ::selection{ background: rgba(10,132,255,0.28); color: inherit }
    html[data-theme="dark"] .ql-editor ::selection{ background: rgba(59,130,246,0.35) }
    html[data-theme="light"] .ql-editor ::selection{ background: rgba(10,132,255,0.28) }
    #pageWrap{
      display:grid; place-items:center; padding:16px;
      background:linear-gradient(var(--bg),var(--bg)) padding-box,
                 radial-gradient(600px 200px at 50% -50px, rgba(255,255,255,0.08), transparent) border-box;
    }
    #page{
      width:816px; min-height:1056px; background:var(--paper);
      border:1px solid var(--paper-edge); border-radius:12px; box-shadow:var(--shadow-paper);
      overflow:visible; position:relative; transform-origin: top center;
    }
    #page .ql-editor{min-height:calc(1056px - 2in); padding:1in; font-size:16px; line-height:1.6}
    /* Title pill */
    .title-pill{ display:inline-flex; align-items:center; border-radius:9999px }
    #docTitle{ width:auto; max-width:60ch }
    #canvasHost{min-height:calc(100vh - 260px)}
    input[type=number]::-webkit-outer-spin-button,input[type=number]::-webkit-inner-spin-button{ -webkit-appearance:none; margin:0}
    input[type=number]{-moz-appearance:textfield; appearance:textfield}
    .z-topbar{z-index:50}.z-menu{z-index:55}.z-drawer{z-index:60}
    /* Active tool: blue/green animated glow for clear state */
    .tool-active{
      background: linear-gradient(135deg, #22d3ee 0%, #10b981 50%, #22d3ee 100%) !important;
      background-size: 200% 200%;
      color: #fff !important;
      animation: ocGradientShift 6s ease-in-out infinite;
      box-shadow: 0 0 0 1px rgba(255,255,255,0.18) inset, 0 6px 18px rgba(34,211,238,0.25);
      border-color: rgba(255,255,255,0.25) !important;
    }

    /* Minimal Quill styles for exported HTML rendering */
    .ql-align-center{text-align:center} .ql-align-right{text-align:right} .ql-align-justify{text-align:justify}
    .ql-indent-1{margin-left:3em} .ql-indent-2{margin-left:6em} .ql-indent-3{margin-left:9em}

    /* Responsive layout refinements */
    @media (max-width: 1024px){
      /* Keep fixed 8.5x11 proportions; scale via JS for fit */
      #page{ border-radius:10px }
      #page .ql-editor{ padding:24px }
      #pageWrap{ padding:12px }
      .toolbar-scroll{ overflow-x:auto; overflow-y:visible; -webkit-overflow-scrolling:touch; position:relative; z-index:60 }
      .toolbar-scroll::-webkit-scrollbar{ height:6px }
      .top-actions{ flex-wrap: wrap; justify-content:flex-end }
    .mobile-bar{ display:flex !important }
    }

    /* Print styles to render the document cleanly */
    /* Fullscreen canvas mode (fallback + polish for iOS) */
    body.fs-canvas-on{ overflow:hidden }
    body.fs-canvas-on header,
    body.fs-canvas-on #sidebarDock,
    body.fs-canvas-on section:nth-of-type(1),
    body.fs-canvas-on .mobile-bar{ display:none !important }
    body.fs-canvas-on main{ max-width:100vw; padding:0; margin:0 }
    body.fs-canvas-on #canvasPanel{ display:block !important; margin-top:0 }
    body.fs-canvas-on #canvasHost{ position:fixed; inset:0; border-radius:0 }
    .canvas-fs-exit{ position:absolute; top:12px; right:12px; display:none; z-index:1001 }
    body.fs-canvas-on .canvas-fs-exit, body.fs-active .canvas-fs-exit{ display:inline-flex }
    .canvas-fs-toolbar{ position:absolute; top:calc(env(safe-area-inset-top, 0px) + 12px); left:50%; transform: translateX(-50%); display:flex; z-index:1002 }
    /* Hide big toolbar in immersive fullscreen */
    body.fs-canvas-on .canvas-toolbar, body.fs-active .canvas-toolbar{ display:none !important }

    /* Print styles to render the document cleanly */
    @media print{
      body, html{ background:#fff; color:#000 }
      header, #canvasPanel, #historyDrawer, .mobile-bar{ display:none !important }
      main{ margin:0; padding:0 }
      #pageWrap{ background:#fff; box-shadow:none; border:none; padding:0 }
      #page{ width:816px; min-height:1056px; border:none; box-shadow:none }
      #page .ql-editor{ padding:1in; color:#000 }
    }
    /* Safe area for notches */
    .safe-pad-bottom{ padding-bottom: env(safe-area-inset-bottom) }

    /* Sidebar (ChatGPT-style) */
    @media (min-width: 1024px){
      body.with-sidebar{ padding-left: 300px }
      /* Make header span the entire viewport width despite body padding */
      body.with-sidebar header{ margin-left: -300px; width: calc(100% + 300px) }
    }
    body.sidebar-collapsed #sidebarDock{ display:none !important }
    #sidebarDock{ width:300px; position:fixed; left:0; top:var(--topbar-h,64px); bottom:0; padding:12px; display:none }
    @media (min-width:1024px){ #sidebarDock{ display:block } }
    #sidebarPanel{ height:100%; display:flex; flex-direction:column }
    #sidebarList{ overflow:auto; overscroll-behavior:contain }
    .note-row{ cursor:pointer }
    .note-row:hover{ background-color: rgba(255,255,255,0.06) }
    .note-row.active{ outline:1px solid var(--line); background-color: rgba(255,255,255,0.08) }

    /* Glowing blue/green plus (OpenCounsel-style) */
    .plus-glow{
      display:inline-flex; align-items:center; justify-content:center; width:22px; height:22px; margin-right:8px;
      border-radius:999px; color:white; font-weight:700; font-size:14px;
      background: linear-gradient(135deg, #22d3ee 0%, #10b981 50%, #22d3ee 100%);
      background-size: 200% 200%;
      box-shadow: 0 0 0 1px rgba(255,255,255,0.08) inset, 0 0 24px rgba(16,185,129,0.35), 0 4px 16px rgba(34,211,238,0.25);
      animation: ocGradientShift 6s ease-in-out infinite;
    }
    .plus-glow svg{ width:14px; height:14px; display:block }
    .mobile-bar .plus-glow{ margin-right:0 }
    @keyframes ocGradientShift{
      0%{ background-position: 0% 50% }
      50%{ background-position: 100% 50% }
      100%{ background-position: 0% 50% }
    }

    /* Quill font + size (Apple-like options) */
    .ql-snow .ql-picker.ql-font .ql-picker-label::before,
    .ql-snow .ql-picker.ql-font .ql-picker-item::before { content: attr(data-label); }
    .ql-font-system{ font-family: ui-sans-serif, SF Pro Text, -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Helvetica Neue, Arial, Noto Sans, Apple Color Emoji, Segoe UI Emoji, Segoe UI Symbol; }
    .ql-font-serif{ font-family: ui-serif, Georgia, Cambria, "Times New Roman", Times, serif; }
    .ql-font-mono{ font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; }
    .ql-font-georgia{ font-family: Georgia, Cambria, "Times New Roman", Times, serif; }
    .ql-font-garamond{ font-family: Garamond, Baskerville, "Times New Roman", Times, serif; }
    .ql-size-12px{ font-size:12px; }
    .ql-size-14px{ font-size:14px; }
    .ql-size-16px{ font-size:16px; }
    .ql-size-18px{ font-size:18px; }
    .ql-size-24px{ font-size:24px; }
    .ql-size-32px{ font-size:32px; }
    .ql-size-48px{ font-size:48px; }

    /* Menu panel polish */
    .menu-panel{ backdrop-filter: blur(12px); background: var(--panel-2); border: 1px solid var(--line); box-shadow: 0 18px 50px rgba(0,0,0,0.35); border-radius: 12px; overflow: hidden; }
    .menu-item{ width:100%; text-align:left; padding:8px 12px; }
    .menu-item:hover{ background: rgba(255,255,255,0.10); }

    /* Quill picker dropdown fixes (mobile + desktop) */
    .ql-snow .ql-picker{ color: var(--text); }
    .ql-snow .ql-picker-label{ padding: 6px 10px; border:none }
    .ql-snow .ql-picker-options{ background: var(--panel-2); border:1px solid var(--line); border-radius: 10px; box-shadow: 0 18px 50px rgba(0,0,0,0.35); padding:6px; z-index: 1000; }
    .ql-snow .ql-picker-item{ padding: 6px 10px; border-radius: 8px }
    .ql-snow .ql-picker-item:hover{ background: rgba(255,255,255,0.10); }
    /* Accessible focus ring */
    :focus-visible{ outline:2px solid var(--accent); outline-offset:2px }
    #historyDrawer .plus-glow{ margin-right: 0 }

    /* Font picker labels */
    .ql-snow .ql-picker.ql-font .ql-picker-label[data-value="system"]::before,
    .ql-snow .ql-picker.ql-font .ql-picker-item[data-value="system"]::before{ content:"System" }
    .ql-snow .ql-picker.ql-font .ql-picker-label[data-value="serif"]::before,
    .ql-snow .ql-picker.ql-font .ql-picker-item[data-value="serif"]::before{ content:"Serif" }
    .ql-snow .ql-picker.ql-font .ql-picker-label[data-value="mono"]::before,
    .ql-snow .ql-picker.ql-font .ql-picker-item[data-value="mono"]::before{ content:"Mono" }
    .ql-snow .ql-picker.ql-font .ql-picker-label[data-value="georgia"]::before,
    .ql-snow .ql-picker.ql-font .ql-picker-item[data-value="georgia"]::before{ content:"Georgia" }
    .ql-snow .ql-picker.ql-font .ql-picker-label[data-value="garamond"]::before,
    .ql-snow .ql-picker.ql-font .ql-picker-item[data-value="garamond"]::before{ content:"Garamond" }

    /* Size picker labels */
    .ql-snow .ql-picker.ql-size .ql-picker-label[data-value="12px"]::before,
    .ql-snow .ql-picker.ql-size .ql-picker-item[data-value="12px"]::before{ content:"12" }
    .ql-snow .ql-picker.ql-size .ql-picker-label[data-value="14px"]::before,
    .ql-snow .ql-picker.ql-size .ql-picker-item[data-value="14px"]::before{ content:"14" }
    .ql-snow .ql-picker.ql-size .ql-picker-label[data-value="16px"]::before,
    .ql-snow .ql-picker.ql-size .ql-picker-item[data-value="16px"]::before{ content:"16" }
    .ql-snow .ql-picker.ql-size .ql-picker-label[data-value="18px"]::before,
    .ql-snow .ql-picker.ql-size .ql-picker-item[data-value="18px"]::before{ content:"18" }
    .ql-snow .ql-picker.ql-size .ql-picker-label[data-value="24px"]::before,
    .ql-snow .ql-picker.ql-size .ql-picker-item[data-value="24px"]::before{ content:"24" }
    .ql-snow .ql-picker.ql-size .ql-picker-label[data-value="32px"]::before,
    .ql-snow .ql-picker.ql-size .ql-picker-item[data-value="32px"]::before{ content:"32" }
    .ql-snow .ql-picker.ql-size .ql-picker-label[data-value="48px"]::before,
    .ql-snow .ql-picker.ql-size .ql-picker-item[data-value="48px"]::before{ content:"48" }
  </style>
</head>
<body class="h-full selection:bg-white/20">

  <!-- ======= TOP BAR ======= -->
  <header class="sticky top-0 z-topbar">
    <div class="grad-bg">
      <div class="glass border-b" style="border-color: var(--line)">
        <div class="w-full flex items-center justify-between gap-3 px-4 py-2">
          <div class="flex items-center gap-3">
            <div class="w-8 h-8 rounded-xl bg-white/90 text-black grid place-content-center font-bold">OC</div>
            <div class="leading-tight">
              <div class="text-white/95" style="color:var(--text)"><strong>OC Notes</strong></div>
              <div class="text-xs" style="color:var(--muted)">Hybrid Word Ã— Obsidian â€” local, private</div>
            </div>
          </div>

          <div class="flex items-center gap-2">
            <!-- Mobile hamburger only -->
            <button id="menuBtn" class="lg:hidden px-3 py-2 glass-2 hover:bg-white/20 rounded-xl border text-sm" style="border-color:var(--line)" aria-label="Open menu">â˜°</button>

            <!-- Desktop actions only -->
          <div class="hidden lg:flex items-center gap-2 top-actions">
              <button id="toggleSidebar" class="px-3 py-2 glass-2 hover:bg-white/20 rounded-xl border text-sm" style="border-color:var(--line)">History</button>
              <button id="newBtn"   class="px-3 py-2 glass-2 hover:bg-white/20 rounded-xl border text-sm flex items-center" style="border-color:var(--line)"><span class="plus-glow" aria-hidden="true"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round"><path d="M12 5v14M5 12h14"/></svg></span>New</button>
              <button id="openBtn"  class="px-3 py-2 glass-2 hover:bg-white/20 rounded-xl border text-sm" style="border-color:var(--line)">Openâ€¦</button>
              <button id="saveBtn"  class="px-3 py-2 glass-2 hover:bg-white/20 rounded-xl border text-sm" style="border-color:var(--line)">Save âŒ˜S</button>

              <!-- Export -->
              <div class="relative">
                <button id="exportBtn" class="px-3 py-2 glass-2 hover:bg-white/20 rounded-xl border text-sm" style="border-color:var(--line)" aria-haspopup="menu" aria-expanded="false">Export â–¼</button>
                <div id="exportMenu" class="hidden absolute right-0 mt-2 w-56 menu-panel z-menu" role="menu" aria-label="Export options">
                  <button class="menu-item" data-export="docx">Export as .docx (Word)</button>
                  <button class="menu-item" data-export="pdf">Export as .pdf</button>
                  <button class="menu-item" data-export="html">Export as .html</button>
                  <button class="menu-item" data-export="json">Export project (.ocnote)</button>
                </div>
              </div>

              <!-- Mode toggle -->
              <div class="ml-2 flex items-center rounded-xl glass-2 border overflow-hidden" style="border-color:var(--line)">
                <button id="modeDoc" class="px-3 py-2 text-sm bg-white/10">Document</button>
                <button id="modeCanvas" class="px-3 py-2 text-sm hover:bg-white/10">Canvas</button>
              </div>

              <!-- Theme toggle -->
              <button id="themeBtn" title="Toggle Light/Dark" class="ml-2 px-3 py-2 glass-2 hover:bg-white/20 rounded-xl border text-sm" style="border-color:var(--line)">â˜€ï¸Ž/ðŸŒ™</button>
            </div>
          </div>
        </div>
      </div>
    </div>
</header>

  <!-- ======= SIDEBAR (Desktop) ======= -->
  <aside id="sidebarDock" class="px-3">
    <div id="sidebarPanel" class="glass rounded-2xl border p-3" style="border-color:var(--line)">
      <div class="flex items-center gap-2 mb-2">
        <button id="sbNew" class="px-3 py-2 glass-2 hover:bg-white/20 rounded-xl border text-sm flex items-center flex-shrink-0" style="border-color:var(--line)"><span class="plus-glow" aria-hidden="true"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round"><path d="M12 5v14M5 12h14"/></svg></span>New</button>
        <input id="sidebarSearch" placeholder="Search notesâ€¦" class="w-full glass-2 border rounded-xl px-3 py-2 outline-none" style="border-color:var(--line); color:var(--text)" />
      </div>
      <div id="sidebarList" class="space-y-2 pr-1"></div>
    </div>
  </aside>

  <!-- ======= TITLE ROW ======= -->
  <section class="max-w-[1200px] mx-auto px-4 mt-3">
    <div class="flex items-center gap-2">
      <div class="title-pill glass-2 border px-3 py-1.5" style="border-color:var(--line)">
        <input id="docTitle" class="bg-transparent outline-none text-lg md:text-xl font-semibold" style="color:var(--text)" placeholder="Untitled note" />
      </div>
      <span id="dirtyDot" class="w-2.5 h-2.5 rounded-full bg-rose-400/80 hidden" title="Unsaved changes"></span>
    </div>
  </section>

  <!-- ======= MAIN PANELS ======= -->
  <main class="max-w-[1200px] mx-auto px-4 mt-2">
    <!-- Document Mode -->
    <div id="docPanel" class="space-y-3">
      <div id="quillToolbar" class="rounded-2xl toolbar-scroll"></div>
      <div id="pageWrap" class="rounded-2xl glass border" style="border-color:var(--line)">
        <div id="page"><div id="quillEditor"></div></div>
      </div>
    </div>

    <!-- Canvas Mode -->
      <div id="canvasPanel" class="hidden">
      <!-- Canvas Toolbar -->
      <div id="canvasToolDock" class="canvas-toolbar glass rounded-2xl border p-2 flex flex-wrap items-center gap-2" style="border-color:var(--line)">
        <button class="tool" data-tool="select" title="V">Move</button>
        <button class="tool" data-tool="text"   title="T">Text</button>
        <button class="tool" data-tool="sticky" title="N">Sticky</button>
        <button class="tool" data-tool="draw"   title="P">Pen</button>
        <button class="tool" data-tool="erase"  title="âŒ«">Delete</button>

        <div class="ml-2 flex items-center gap-2">
          <label class="text-sm" style="color:var(--muted)">Brush</label>
          <input id="brushSize" type="range" min="1" max="24" value="3" />
        </div>

        <div class="ml-2 flex items-center gap-2">
          <label class="text-sm" style="color:var(--muted)">Color</label>
          <input id="brushColor" type="color" value="#ffffff" class="w-9 h-9 p-0 bg-transparent border rounded-lg" style="border-color:var(--line)" />
        </div>

        <!-- Grid + Snap -->
        <div class="ml-4 flex items-center gap-2">
          <label class="text-sm" style="color:var(--muted)">Grid</label>
          <input id="gridToggle" type="checkbox" />
          <label class="text-sm" style="color:var(--muted)">Snap</label>
          <input id="snapToggle" type="checkbox" />
          <label class="text-sm" style="color:var(--muted)">Size</label>
          <input id="gridSize" type="number" value="24" min="4" max="200" class="w-16 glass-2 border rounded-lg px-2 py-1 text-sm" style="border-color:var(--line)" />
        </div>

        <!-- Canvas BG -->
        <div class="ml-4 flex items-center gap-2">
          <label class="text-sm" style="color:var(--muted)">Canvas BG</label>
          <input id="canvasBg" type="color" value="#0f0f11" class="w-9 h-9 p-0 bg-transparent border rounded-lg" style="border-color:var(--line)" />
        </div>

        <div class="ml-auto flex items-center gap-2">
          <button id="zoomOut" class="px-3 py-1.5 glass-2 hover:bg-white/20 rounded-lg border text-sm" style="border-color:var(--line)">âˆ’</button>
          <input id="zoomLevel" type="number" class="w-16 glass-2 border rounded-lg px-2 py-1 text-sm" style="border-color:var(--line)" value="100" />%
          <button id="zoomIn" class="px-3 py-1.5 glass-2 hover:bg-white/20 rounded-lg border text-sm" style="border-color:var(--line)">+</button>
          <button id="centerCanvas" class="px-3 py-1.5 glass-2 hover:bg-white/20 rounded-lg border text-sm" style="border-color:var(--line)">Center</button>
          <button id="clearCanvas" class="px-3 py-1.5 glass-2 hover:bg-white/20 rounded-lg border text-sm" style="border-color:var(--line)">Clear</button>
        </div>
        <div class="basis-full text-xs opacity-70 mt-1" style="color:var(--muted)">
          Move tool to drag Â· Text tool to type Â· Space = pan Â· Wheel = zoom
        </div>
      </div>

      <!-- Canvas Surface -->
      <div id="canvasHost" class="glass rounded-2xl border mt-3 overflow-hidden" style="border-color:var(--line); position:relative">
        <div id="fsToolbar" class="canvas-fs-toolbar glass border rounded-xl px-2 py-1.5 flex items-center gap-1" style="border-color:var(--line)">
          <button id="fsToolbarExit" class="px-2 py-1 text-sm rounded-lg hover:bg-white/10 border" style="border-color:var(--line)">Full</button>
          <div class="h-5 w-px bg-white/10 mx-1"></div>
          <button class="px-2 py-1 text-sm rounded-lg hover:bg-white/10 border tool" style="border-color:var(--line)" data-tool="select">Move</button>
          <button class="px-2 py-1 text-sm rounded-lg hover:bg-white/10 border tool" style="border-color:var(--line)" data-tool="sticky">Sticky</button>
          <button class="px-2 py-1 text-sm rounded-lg hover:bg-white/10 border tool" style="border-color:var(--line)" data-tool="text">Text</button>
          <button class="px-2 py-1 text-sm rounded-lg hover:bg-white/10 border tool" style="border-color:var(--line)" data-tool="draw">Pen</button>
          <button class="px-2 py-1 text-sm rounded-lg hover:bg-white/10 border tool" style="border-color:var(--line)" data-tool="erase">Erase</button>
          <div class="h-5 w-px bg-white/10 mx-1"></div>
          <input id="fsColor" type="color" class="w-7 h-7 p-0 bg-transparent border rounded-lg" style="border-color:var(--line)" title="Text/Brush Color" />
          <input id="fsBrush" type="range" min="1" max="24" value="3" class="align-middle" title="Pen Thickness" style="width:90px" />
          <div class="h-5 w-px bg-white/10 mx-1"></div>
          <button id="fsUndo" class="px-2 py-1 text-sm rounded-lg hover:bg-white/10 border" style="border-color:var(--line)">Undo</button>
          <button id="fsRedo" class="px-2 py-1 text-sm rounded-lg hover:bg-white/10 border" style="border-color:var(--line)">Redo</button>
        </div>
        <canvas id="ocCanvas"></canvas>
      </div>
    </div>
  </main>

  <!-- ======= HISTORY DRAWER ======= -->
  <div id="historyDrawer" class="fixed inset-0 hidden z-drawer">
    <div class="absolute inset-0 bg-black/50" data-close-history></div>
    <div class="absolute left-0 top-0 h-full w-[360px] glass border-r p-4 overflow-y-auto" style="border-color:var(--line)">
      <div class="flex items-center justify-between mb-3">
        <h3 class="text-lg font-semibold" style="color:var(--text)">Workspaces</h3>
        <div class="flex items-center gap-2">
          <button id="drawerNew" class="w-9 h-9 grid place-content-center glass-2 hover:bg-white/20 rounded-lg border" style="border-color:var(--line)" title="New workspace" aria-label="New workspace"><span class="plus-glow" aria-hidden="true"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round"><path d="M12 5v14M5 12h14"/></svg></span></button>
          <button data-close-history class="px-3 py-1.5 glass-2 hover:bg-white/20 rounded-lg border text-sm" style="border-color:var(--line)">Close</button>
        </div>
      </div>
      <div class="mb-3">
        <input id="searchHistory" placeholder="Searchâ€¦" class="w-full glass-2 border rounded-xl px-3 py-2 outline-none" style="border-color:var(--line); color:var(--text)" />
      </div>
      <div id="historyList" class="space-y-2"></div>
      <div class="mt-4 pt-3 border-t" style="border-color:var(--line)">
        <div class="text-xs mb-2" style="color:var(--muted)">Export current</div>
        <div class="grid grid-cols-2 gap-2">
          <button class="px-3 py-2 glass-2 hover:bg-white/20 rounded-xl border text-sm" style="border-color:var(--line)" data-drawer-export="docx">DOCX</button>
          <button class="px-3 py-2 glass-2 hover:bg-white/20 rounded-xl border text-sm" style="border-color:var(--line)" data-drawer-export="pdf">PDF</button>
          <button class="px-3 py-2 glass-2 hover:bg-white/20 rounded-xl border text-sm" style="border-color:var(--line)" data-drawer-export="html">HTML</button>
          <button class="px-3 py-2 glass-2 hover:bg-white/20 rounded-xl border text-sm" style="border-color:var(--line)" data-drawer-export="json">Project</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Hidden file input -->
  <input id="openFile" type="file" accept=".ocnote,application/json" class="hidden" />


  <!-- Offscreen export staging (used by PDF if ever needed) -->
  <div id="exportStage" style="position:absolute; left:-9999px; top:0; width:816px; background:#fff; color:#000; padding:24px;"></div>

  <script>
    /* =============== UTILITIES =============== */
    const $  = (sel, el=document) => el.querySelector(sel);
    const $$ = (sel, el=document) => Array.from(el.querySelectorAll(sel));
    const uid = () => 'oc_' + Math.random().toString(36).slice(2) + Date.now().toString(36);
    const nowISO = () => new Date().toISOString();
    const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
    const safeFileName = (name) => (name || 'note').replace(/[^a-z0-9\-]+/gi,'_');
    const escapeHtml = (str) => (str+'').replace(/[&<>"']/g, s=>({"&":"&amp;","<":"&lt;","&gt;":"&gt;","\"":"&quot;","'":"&#39;"}[s]));
    const niceDate = (iso) => { try { return new Date(iso).toLocaleString(); } catch { return iso; } }
    const isSafari = () => /^((?!chrome|android).)*safari/i.test(navigator.userAgent);

    function debounce(fn, ms=300){ let t; return (...args)=>{ clearTimeout(t); t=setTimeout(()=>fn(...args),ms) }; }
    function flash(msg) {
      const div = document.createElement('div');
      div.textContent = msg;
      div.className = 'fixed bottom-5 left-1/2 -translate-x-1/2 px-4 py-2 rounded-xl glass border text-white';
      div.style.borderColor = getComputedStyle(document.body).getPropertyValue('--line');
      document.body.appendChild(div);
      setTimeout(()=>div.remove(), 1300);
    }

    // Robust downloader with Safari/iOS fallback for DOCX
    async function downloadBlob(blob, filename) {
      const mime = blob.type || 'application/octet-stream';
      const a = document.createElement('a');
      const url = URL.createObjectURL(blob);
      const canDownload = 'download' in a && !isSafari();

      if (canDownload) {
        a.href = url; a.download = filename; document.body.appendChild(a); a.click(); a.remove();
        setTimeout(() => URL.revokeObjectURL(url), 4000);
      } else {
        // Safari/iOS fallback: open in a new tab so user can "Save"
        try {
          const data = await blobToDataURL(blob);
          const win = window.open(data, '_blank');
          if (!win) {
            // if popup blocked, navigate current tab
            location.href = data;
          }
        } finally {
          setTimeout(() => URL.revokeObjectURL(url), 0);
        }
      }
    }
    function blobToDataURL(blob){
      return new Promise((res, rej) => {
        const fr = new FileReader();
        fr.onload = () => res(fr.result);
        fr.onerror = rej;
        fr.readAsDataURL(blob);
      });
    }

    /* =============== PERSISTENCE =============== */
    const store = {
      key: 'oc_notes_history_v4',
      themeKey: 'oc_theme',
      sidebarKey: 'oc_sidebar_open',
      loadAll() { try { return JSON.parse(localStorage.getItem(this.key)) || []; } catch { return []; } },
      saveAll(list) { localStorage.setItem(this.key, JSON.stringify(list)); },
      upsert(doc) {
        const list = this.loadAll();
        const idx = list.findIndex(x => x.id === doc.id);
        if (idx >= 0) list[idx] = doc; else list.unshift(doc);
        this.saveAll(list.slice(0,25));
      },
      saveTheme(v){ localStorage.setItem(this.themeKey, v); },
      loadTheme(){ return localStorage.getItem(this.themeKey); },
      saveSidebarOpen(v){ localStorage.setItem(this.sidebarKey, v ? '1':'0'); },
      loadSidebarOpen(){ return localStorage.getItem(this.sidebarKey) !== '0'; }
    };

    /* =============== STATE =============== */
    const state = {
      id: uid(),
      mode: 'doc', // 'doc' | 'canvas'
      dirty: false,
      quill: null,
      canvas: null,
      hist: { stack: [], idx: -1 },
      suppressHistory: false,
      currentTool: 'select',     // 'select'|'text'|'sticky'|'draw'|'erase'
      awaitingPlacement: null,   // for click-to-place when 'text' or 'sticky'
      zoom: 1,
      isSpacePanning: false,
      grid: { show:false, snap:false, size:24, targetTol:10 },
      sidebarOpen: true,
      docScale: 1,
    };
    const markDirty = () => { state.dirty = true; $('#dirtyDot').classList.remove('hidden'); try { autoSave && autoSave(); } catch {} }
    const clearDirty = () => { state.dirty = false; $('#dirtyDot').classList.add('hidden'); }

    /* =============== THEME =============== */
    function applyTheme(t) {
      document.documentElement.setAttribute('data-theme', t);
      if (t === 'dark') document.documentElement.classList.add('dark');
      else document.documentElement.classList.remove('dark');
      store.saveTheme(t);
      // update theme-color meta for nicer mobile UI
      const metaTags = document.querySelectorAll('meta[name="theme-color"]');
      metaTags.forEach(m => {
        if (t==='dark' && m.media?.includes('dark')) m.setAttribute('content', '#0b0b0b');
        if (t==='light' && m.media?.includes('light')) m.setAttribute('content', '#f5f5f7');
      });
    }
    function toggleTheme() {
      applyTheme((document.documentElement.getAttribute('data-theme') || 'dark') === 'dark' ? 'light' : 'dark');
    }

    /* =============== QUILL =============== */
    function renderQuillToolbar() {
      $('#quillToolbar').innerHTML = `
        <div class="glass border rounded-2xl p-2 flex flex-wrap gap-2 items-center" style="border-color:var(--line)">
          <span class="ql-formats">
            <select class="ql-font">
              <option selected value="system" data-label="System">System</option>
              <option value="serif" data-label="Serif">Serif</option>
              <option value="mono" data-label="Mono">Mono</option>
              <option value="georgia" data-label="Georgia">Georgia</option>
              <option value="garamond" data-label="Garamond">Garamond</option>
            </select>
          </span>
          <span class="ql-formats">
            <select class="ql-header"><option selected></option><option value="1">H1</option><option value="2">H2</option><option value="3">H3</option></select>
          </span>
          <span class="ql-formats">
            <button class="ql-bold"></button><button class="ql-italic"></button>
            <button class="ql-underline"></button><button class="ql-strike"></button>
          </span>
          <span class="ql-formats">
            <button class="ql-list" value="ordered"></button><button class="ql-list" value="bullet"></button>
          </span>
          <span class="ql-formats"><select class="ql-align"></select></span>
          <span class="ql-formats"><button class="ql-link"></button><button class="ql-image"></button><button class="ql-code-block"></button></span>
          <span class="ql-formats"><button class="ql-indent" value="-1"></button><button class="ql-indent" value="+1"></button></span>
          <span class="ql-formats"><select class="ql-color"></select><select class="ql-background"></select></span>
          <span class="ql-formats">
            <select class="ql-size">
              <option value="12px">12</option>
              <option value="14px">14</option>
              <option selected value="16px">16</option>
              <option value="18px">18</option>
              <option value="24px">24</option>
              <option value="32px">32</option>
              <option value="48px">48</option>
            </select>
          </span>
          <span class="ql-formats"><button class="ql-clean"></button></span>
        </div>`;
    }
    function initQuill() {
      renderQuillToolbar();
      // Register custom font & size whitelists
      const Font = Quill.import('attributors/class/font');
      Font.whitelist = ['system','serif','mono','georgia','garamond'];
      Quill.register(Font, true);
      const Size = Quill.import('attributors/class/size');
      Size.whitelist = ['12px','14px','16px','18px','24px','32px','48px'];
      Quill.register(Size, true);

      const q = new Quill('#quillEditor', { theme:'snow', modules:{ toolbar:'#quillToolbar' } });
      state.quill = q;
      q.on('text-change', markDirty);
    }

    /* =============== FABRIC CANVAS =============== */
    function initCanvas() {
      const host = $('#canvasHost');
      const cEl = $('#ocCanvas');
      const canvas = new fabric.Canvas(cEl, {
        backgroundColor: '#0f0f11',
        selection: true,
        preserveObjectStacking: true,
        perPixelTargetFind: true,
        targetFindTolerance: state.grid.targetTol
      });
      state.canvas = canvas;
      try { canvas.upperCanvasEl.setAttribute('tabindex','1'); } catch {}

      // Fallback eraser brush if Fabric doesn't provide one
      if (!fabric.EraserBrush) {
        fabric.EraserBrush = fabric.util.createClass(fabric.PencilBrush, {
          initialize: function(canvas){ this.callSuper('initialize', canvas); },
          onMouseDown: function(pointer, options){
            this.canvas.contextTop.save();
            this.canvas.contextTop.globalCompositeOperation = 'destination-out';
            this.color = 'rgba(0,0,0,1)';
            return this.callSuper('onMouseDown', pointer, options);
          },
          onMouseMove: function(pointer, options){
            return this.callSuper('onMouseMove', pointer, options);
          },
          onMouseUp: function(options){
            const r = this.callSuper('onMouseUp', options);
            try { this.canvas.contextTop.restore(); } catch {}
            return r;
          },
          _finalizeAndAddPath: function() {
            const ctx = this.canvas.contextTop;
            ctx.closePath();
            if (this._points && this._points.length > 1) {
              const pathData = this.convertPointsToSVGPath(this._points).join('');
              if (pathData === 'M 0 0 Q 0 0 0 0 L 0 0') { this.canvas.clearContext(this.canvas.contextTop); this._reset(); return null; }
              const path = this.createPath(pathData);
              path.set({
                fill: null,
                stroke: '#000',
                strokeWidth: this.width,
                globalCompositeOperation: 'destination-out',
                selectable: false,
                evented: false,
                strokeUniform: true
              });
              // add to canvas and render
              this.canvas.add(path);
              this.canvas.requestRenderAll();
              // hook: mark dirty and history if available
              try { markDirty(); if (typeof pushHistoryDebounced === 'function') pushHistoryDebounced(); } catch {}
              this._reset();
              return path;
            }
            this.canvas.clearContext(this.canvas.contextTop);
            this._reset();
            return null;
          }
        });
      }
      const SAVE_PROPS = ['selectable','evented','stroke','strokeWidth','fill','fontSize','backgroundColor','padding','rx','ry','strokeUniform','globalCompositeOperation','eraser'];
      function pushHistory(){
        if (!canvas || state.suppressHistory) return;
        try {
          const snap = { json: canvas.toJSON(SAVE_PROPS), bg: canvas.backgroundColor || '#0f0f11' };
          state.hist.stack = state.hist.stack.slice(0, state.hist.idx + 1);
          state.hist.stack.push(snap);
          state.hist.idx = state.hist.stack.length - 1;
        } catch {}
      }
      const pushHistoryDebounced = debounce(pushHistory, 250);
      canvas.__pushHistoryDebounced = pushHistoryDebounced;
      async function loadHistoryAt(idx){
        if (idx < 0 || idx >= state.hist.stack.length) return;
        const snap = state.hist.stack[idx];
        state.suppressHistory = true;
        try {
          await new Promise(res => canvas.loadFromJSON(snap.json, () => res()));
          if (snap.bg) canvas.setBackgroundColor(snap.bg, canvas.renderAll.bind(canvas));
          canvas.requestRenderAll();
        } finally {
          state.suppressHistory = false;
        }
      }
      async function undoCanvas(){ if (state.hist.idx > 0) { state.hist.idx--; await loadHistoryAt(state.hist.idx); } }
      async function redoCanvas(){ if (state.hist.idx < state.hist.stack.length - 1) { state.hist.idx++; await loadHistoryAt(state.hist.idx); } }

      const resize = () => {
        const vv = window.visualViewport;
        const vw = (vv?.width) ? Math.round(vv.width) : (host.clientWidth || window.innerWidth || 1200);
        const fsOn = !!document.fullscreenElement || document.body.classList.contains('fs-canvas-on');
        const vh = (vv?.height) ? Math.round(vv.height) : window.innerHeight;
        const h = fsOn ? vh : Math.max(600, window.innerHeight - 260);
        cEl.width = vw; cEl.height = h;
        canvas.setWidth(vw); canvas.setHeight(h);
        canvas.requestRenderAll();
      };
      resize();
      window.addEventListener('resize', debounce(resize, 120));

      // drawing defaults
      canvas.isDrawingMode = false;
      canvas.freeDrawingBrush.width = 3;
      canvas.freeDrawingBrush.color = '#ffffff';

      // Make paths draggable from stroke area; better UX
      canvas.on('path:created', (e) => {
        const p = e.path;
        const isErase = (state.currentTool === 'erase');
        if (!isErase) {
          p.set({
            selectable:true, evented:true, hasControls:true, hasBorders:true,
            hoverCursor:'move', fill:null, strokeUniform:true, erasable:true
          });
          p.set({ stroke: $('#brushColor').value || '#ffffff', strokeWidth: Number($('#brushSize').value || 3) });
        } else {
          // Eraser path: use compositing fallback if EraserBrush not available
          p.set({ selectable:false, evented:false, hasControls:false, hasBorders:false, fill:null, strokeUniform:true, eraser:true });
          if (!fabric.EraserBrush) {
            p.globalCompositeOperation = 'destination-out';
            // make stroke fully transparent so no ink is seen if composite not applied on preview
            p.stroke = 'rgba(0,0,0,1)';
            p.strokeWidth = Number($('#brushSize').value || 12);
          }
        }
        markDirty(); pushHistoryDebounced();
      });

      // ===== Interaction rules by tool =====
      // 1) Text tool: click empty -> create textbox; click textbox/sticky -> edit; drawings are ignored (no move)
      // 2) Move tool: drag anything; no typing; textboxes only enter edit on double-click (Fabric default)

      canvas.on('mouse:down', (opt) => {
        try { if (document.activeElement && document.activeElement !== document.body) document.activeElement.blur(); } catch {}
        const target = opt.target;
        const pt = canvas.getPointer(opt.e);

        // Space-pan start
        if (state.isSpacePanning) {
          canvas.isDragging = true;
          canvas.selection = false;
          canvas.lastPosX = opt.e.clientX;
          canvas.lastPosY = opt.e.clientY;
          return;
        }

        // Touch-friendly quick edit when in Move tool: single tap edits text
        if (state.currentTool === 'select' && target && (target.type === 'textbox' || target.type === 'i-text')) {
          const isTouch = !!(opt.e && (opt.e.touches || opt.e.pointerType === 'touch'));
          if (isTouch) {
            if (!target.isEditing) {
              canvas.setActiveObject(target);
              target.enterEditing();
              if (target.hiddenTextarea) { try { target.hiddenTextarea.focus(); } catch {} }
              setTimeout(()=>{ try { target.hiddenTextarea && target.hiddenTextarea.focus({ preventScroll:true }); } catch {} }, 0);
              return;
            }
          }
        }

        // If Text tool is active:
        if (state.currentTool === 'text') {
          // Clicked on existing textbox? enter edit
          if (target && target.type === 'textbox') {
            if (!target.isEditing) {
              canvas.setActiveObject(target);
              target.enterEditing();
              target.hiddenTextarea && target.hiddenTextarea.focus();
              // Put caret at end for natural typing
              const len = target.text?.length ?? 0;
              target.setSelectionStart(len);
              target.setSelectionEnd(len);
            }
            return;
          }
          // Clicked on sticky? (we model sticky as textbox with backgroundColor)
          if (target && target.type !== 'textbox') {
            // ignore moves while in text mode
            return;
          }
          // Empty space: create new textbox for typing
          const tb = new fabric.Textbox('',
            { left: pt.x, top: pt.y, width: 320, fontSize: 20, editable: true,
              fill: $('#brushColor').value || '#ffffff',
              backgroundColor: 'rgba(255,255,255,0.04)', padding: 8, cornerStyle:'circle',
              erasable: true
            });
          canvas.add(tb);
          canvas.setActiveObject(tb);
          tb.enterEditing();
          if (tb.hiddenTextarea) { try { tb.hiddenTextarea.focus(); } catch {} }
          setTimeout(()=>{ try { tb.hiddenTextarea && tb.hiddenTextarea.focus({ preventScroll:true }); } catch {} }, 0);
          canvas.requestRenderAll();
          markDirty(); pushHistoryDebounced();
          return;
        }

        // If Sticky tool: place sticky, then auto-switch to Text tool and edit immediately
        if (state.currentTool === 'sticky') {
          const sticky = new fabric.Textbox('',
            { left: pt.x, top: pt.y, width: 260, fontSize: 18, editable: true,
              fill:'#1f2937', backgroundColor: '#facc15', padding: 10, rx: 12, ry: 12, cornerStyle:'circle',
              erasable: true
            });
          canvas.add(sticky);
          canvas.setActiveObject(sticky);
          // Switch to text tool and start editing
          useTool('text');
          sticky.enterEditing();
          if (sticky.hiddenTextarea) { try { sticky.hiddenTextarea.focus(); } catch {} }
          setTimeout(()=>{ try { sticky.hiddenTextarea && sticky.hiddenTextarea.focus({ preventScroll:true }); } catch {} }, 0);
          canvas.requestRenderAll();
          markDirty(); pushHistoryDebounced();
          return;
        }

        // If Move tool: default Fabric behavior (drag/move); do not enter edit here
        // If Draw tool: Fabric handles drawing
      });

      // prevent entering edit while in Move tool (single-click)
      canvas.on('text:changed', () => { markDirty(); pushHistoryDebounced(); });

      // Space-pan move/end
      canvas.on('mouse:move', (opt) => {
        if (canvas.isDragging) {
          const v = canvas.viewportTransform;
          v[4] += opt.e.clientX - canvas.lastPosX;
          v[5] += opt.e.clientY - canvas.lastPosY;
          canvas.requestRenderAll();
          canvas.lastPosX = opt.e.clientX; canvas.lastPosY = opt.e.clientY;
        }
      });
      canvas.on('mouse:up', () => {
        canvas.isDragging = false;
        canvas.selection = (state.currentTool === 'select');
      });

      // snap-to-grid
      function maybeSnap(target) {
        if (!state.grid.snap) return;
        const gs = state.grid.size;
        target.set({
          left: Math.round(target.left / gs) * gs,
          top:  Math.round(target.top  / gs) * gs
        });
      }
      canvas.on('object:moving', (e) => { maybeSnap(e.target); });
      canvas.on('object:scaling', (e) => { maybeSnap(e.target); });

      // grid overlay
      canvas.on('after:render', () => {
        if (!state.grid.show) return;
        const ctx = canvas.getContext();
        const vpt = canvas.viewportTransform;
        const zoom = canvas.getZoom();
        const gs = state.grid.size * zoom;
        const xStart = -vpt[4] % gs;
        const yStart = -vpt[5] % gs;
        ctx.save();
        ctx.strokeStyle = 'rgba(255,255,255,0.08)';
        ctx.lineWidth = 1;
        for (let x = xStart; x < canvas.getWidth(); x += gs) { ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,canvas.getHeight()); ctx.stroke(); }
        for (let y = yStart; y < canvas.getHeight(); y += gs) { ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(canvas.getWidth(),y); ctx.stroke(); }
        ctx.restore();
      });

      // If Fabric eraser emits events, capture them to history
      try {
        canvas.on('erasing:end', () => { markDirty(); pushHistoryDebounced(); });
      } catch {}

      // wheel zoom
      canvas.on('mouse:wheel', (opt) => {
        const delta = opt.e.deltaY;
        let zoom = state.zoom * (delta > 0 ? 0.95 : 1.05);
        zoom = clamp(zoom, 0.1, 5);
        const point = new fabric.Point(opt.e.offsetX, opt.e.offsetY);
        canvas.zoomToPoint(point, zoom);
        state.zoom = zoom;
        $('#zoomLevel').value = Math.round(zoom * 100);
        opt.e.preventDefault(); opt.e.stopPropagation();
      });

      // keybinds
      function isEditingCanvasText(){
        try{
          const obj = canvas.getActiveObject && canvas.getActiveObject();
          return !!(obj && (obj.isEditing === true || obj.isEditing));
        } catch { return false; }
      }
      // allow double click to edit in any tool
      canvas.on('mouse:dblclick', (opt) => {
        const t = opt.target;
        if (t && (t.type === 'textbox' || t.type === 'i-text')) {
          canvas.setActiveObject(t);
          t.enterEditing();
          t.hiddenTextarea && t.hiddenTextarea.focus();
        }
      });
      window.addEventListener('keydown', (e) => {
        if (state.mode !== 'canvas') return;
        if (isEditingCanvasText()) return; // don't hijack typing while editing text/sticky
        const isMeta = e.ctrlKey || e.metaKey;
        if (isMeta && e.key.toLowerCase() === 'z') { e.preventDefault(); return e.shiftKey ? redoCanvas() : undoCanvas(); }
        const k = e.key.toLowerCase();
        if (k === 'v') useTool('select');
        if (k === 'p') useTool('draw');
        if (k === 't') useTool('text');
        if (k === 'n') useTool('sticky');
        if (e.code === 'Space' && !state.isSpacePanning) {
          state.isSpacePanning = true; canvas.defaultCursor = 'grab'; canvas.selection = false;
        }
        if ((e.key === 'Delete' || e.key === 'Backspace')) {
          const active = canvas.getActiveObjects();
          if (active.length) {
            active.forEach(o => canvas.remove(o));
            canvas.discardActiveObject();
            canvas.requestRenderAll();
            markDirty(); pushHistoryDebounced();
          }
        }
      });
      window.addEventListener('keyup', (e) => {
        if (e.code === 'Space') {
          state.isSpacePanning = false;
          canvas.defaultCursor = (state.currentTool === 'draw') ? 'crosshair' : 'default';
          canvas.selection = (state.currentTool === 'select');
        }
      });

      // mark dirty on object changes
      canvas.on('object:added', () => { markDirty(); pushHistoryDebounced(); });
      canvas.on('object:modified', () => { markDirty(); pushHistoryDebounced(); });
      canvas.on('object:removed', () => { markDirty(); pushHistoryDebounced(); });

      // Tool buttons + active styles
      const toolBtns = $$('#canvasPanel .tool');
      const fsToolBtns = $$('#fsToolbar [data-tool]');
      toolBtns.forEach(btn => {
        btn.classList.add('px-3','py-1.5','glass-2','hover:bg-white/20','rounded-lg','border','text-sm');
        btn.style.borderColor = getComputedStyle(document.body).getPropertyValue('--line');
        btn.addEventListener('click', () => useTool(btn.dataset.tool));
      });
      const setToolActive = (tool) => {
        toolBtns.forEach(b => b.classList.toggle('tool-active', b.dataset.tool === tool));
        fsToolBtns.forEach(b => b.classList.toggle('tool-active', b.dataset.tool === tool));
      };
      fsToolBtns.forEach(btn => btn.addEventListener('click', () => useTool(btn.dataset.tool)));
      const fsUndo = document.getElementById('fsUndo');
      if (fsUndo) fsUndo.addEventListener('click', undoCanvas);
      const fsRedo = document.getElementById('fsRedo');
      if (fsRedo) fsRedo.addEventListener('click', redoCanvas);

      // Controls
      $('#brushSize').addEventListener('input', (e) => {
        const sz = Number(e.target.value || 3);
        if (canvas.isDrawingMode) canvas.freeDrawingBrush.width = sz;
        const active = canvas.getActiveObjects();
        if (active.length) {
          active.forEach(o => { if (o.type === 'path') o.set({ strokeWidth: sz }); });
          canvas.requestRenderAll(); markDirty(); pushHistoryDebounced();
        }
        const fsBrush = document.getElementById('fsBrush'); if (fsBrush) fsBrush.value = String(sz);
      });
      $('#brushColor').addEventListener('input', (e) => {
        const col = e.target.value || '#ffffff';
        if (canvas.isDrawingMode) { canvas.freeDrawingBrush.color = col; return; }
        const active = canvas.getActiveObjects();
        if (active.length) {
          active.forEach(o => applyColor(o, col));
          canvas.requestRenderAll(); markDirty(); pushHistoryDebounced();
        }
        const fsColor = document.getElementById('fsColor'); if (fsColor) fsColor.value = col;
      });
      const fsColor = document.getElementById('fsColor');
      if (fsColor) {
        try { fsColor.value = document.getElementById('brushColor').value || '#ffffff'; } catch {}
        fsColor.addEventListener('input', (e) => {
          const col = e.target.value || '#ffffff';
          // sync main color
          const bc = document.getElementById('brushColor'); if (bc) bc.value = col;
          // apply like main handler
          if (canvas.isDrawingMode) { canvas.freeDrawingBrush.color = col; return; }
          const active = canvas.getActiveObjects();
          if (active.length) {
            active.forEach(o => applyColor(o, col));
            canvas.requestRenderAll(); markDirty();
          }
        });
      }
      const fsBrush = document.getElementById('fsBrush');
      if (fsBrush) {
        try { fsBrush.value = document.getElementById('brushSize').value || '3'; } catch {}
        fsBrush.addEventListener('input', (e) => {
          const sz = Number(e.target.value || 3);
          const main = document.getElementById('brushSize'); if (main) main.value = String(sz);
          if (canvas.isDrawingMode) canvas.freeDrawingBrush.width = sz;
          const active = canvas.getActiveObjects();
          if (active.length) {
            active.forEach(o => { if (o.type === 'path') o.set({ strokeWidth: sz }); });
            canvas.requestRenderAll(); markDirty();
          }
        });
      }
      function applyColor(obj, col){
        if (obj.type === 'path') obj.set({ stroke: col });
        else if (obj.type === 'textbox' || obj.type === 'i-text' || obj.type === 'text') obj.set({ fill: col });
        else if (obj.type === 'group' && obj._objects) obj._objects.forEach(ch => applyColor(ch, col));
        else obj.set({ fill: col });
      }
      $('#clearCanvas').addEventListener('click', () => {
        if (confirm('Clear the canvas?')) {
          canvas.clear();
          canvas.setBackgroundColor($('#canvasBg').value || '#0f0f11', canvas.renderAll.bind(canvas));
          markDirty();
        }
      });
      $('#zoomIn').addEventListener('click', () => setZoom(state.zoom * 1.15));
      $('#zoomOut').addEventListener('click', () => setZoom(state.zoom / 1.15));
      $('#centerCanvas').addEventListener('click', resetViewport);
      $('#zoomLevel').addEventListener('change', (e) => setZoom(clamp((Number(e.target.value)||100)/100, 0.1, 5)));
      
      // Fullscreen toggle
      const fsBtn = document.getElementById('canvasFullscreen');
      function isFullscreen(){ return !!document.fullscreenElement || document.body.classList.contains('fs-canvas-on'); }
      async function enterFS(){
        try { setMode && setMode('canvas'); } catch {}
        const elem = host;
        if (elem.requestFullscreen) { try { await elem.requestFullscreen({ navigationUI: 'hide' }); } catch(_) { document.body.classList.add('fs-canvas-on'); } }
        else { document.body.classList.add('fs-canvas-on'); }
        document.body.classList.add('fs-active');
        fsBtn && (fsBtn.textContent = 'Exit');
        const fsTB = document.getElementById('fsToolbarExit'); if (fsTB) fsTB.textContent = 'Exit';
        resize();
      }
      async function exitFS(){
        if (document.fullscreenElement && document.exitFullscreen) { try { await document.exitFullscreen(); } catch(_) { document.body.classList.remove('fs-canvas-on'); } }
        else { document.body.classList.remove('fs-canvas-on'); }
        document.body.classList.remove('fs-active');
        fsBtn && (fsBtn.textContent = 'Full');
        const fsTB = document.getElementById('fsToolbarExit'); if (fsTB) fsTB.textContent = 'Full';
        resize();
      }
      function toggleFS(){ isFullscreen() ? exitFS() : enterFS(); }
      fsBtn && fsBtn.addEventListener('click', toggleFS);
      document.addEventListener('fullscreenchange', () => {
        const on = isFullscreen();
        document.body.classList.toggle('fs-active', on);
        if (fsBtn) fsBtn.textContent = on ? 'Exit' : 'Full';
        const fsTB = document.getElementById('fsToolbarExit');
        if (fsTB) fsTB.textContent = on ? 'Exit' : 'Full';
        resize();
      });
      const fsToolbarExit = document.getElementById('fsToolbarExit');
      if (fsToolbarExit) fsToolbarExit.addEventListener('click', () => { isFullscreen() ? exitFS() : enterFS(); });
      window.addEventListener('keydown', (e) => { if (e.key === 'Escape' && isFullscreen()) { e.preventDefault(); exitFS(); } });
      function setZoom(z){ state.zoom = clamp(z, 0.1, 5); const c = new fabric.Point(canvas.getWidth()/2, canvas.getHeight()/2); canvas.zoomToPoint(c, state.zoom); $('#zoomLevel').value = Math.round(state.zoom*100); }
      function resetViewport(){ state.zoom = 1; canvas.setViewportTransform([1,0,0,1,0,0]); $('#zoomLevel').value = 100; canvas.requestRenderAll(); }

      // Touch: pinch-zoom and two-finger pan for mobile
      (function enablePinchZoom(){
        const target = canvas.upperCanvasEl;
        let t1=null, t2=null, lastDist=0, lastCenter=null;
        const dist = (a,b)=> Math.hypot(a.clientX-b.clientX, a.clientY-b.clientY);
        const center = (a,b)=> ({ x:(a.clientX+b.clientX)/2, y:(a.clientY+b.clientY)/2 });
        const toPoint = (c)=> new fabric.Point(c.x, c.y);
        target.addEventListener('touchstart', (e)=>{
          if (e.touches.length===2){
            t1 = e.touches[0]; t2 = e.touches[1];
            lastDist = dist(t1,t2); lastCenter = center(t1,t2);
            canvas.isDrawingMode = false; canvas.selection = false;
          }
        }, { passive:false });
        target.addEventListener('touchmove', (e)=>{
          if (e.touches.length===2){
            e.preventDefault();
            t1 = e.touches[0]; t2 = e.touches[1];
            const d = dist(t1,t2);
            const c = center(t1,t2);
            const scale = d / (lastDist || d);
            const newZoom = clamp(canvas.getZoom()*scale, 0.1, 5);
            canvas.zoomToPoint(toPoint(c), newZoom);
            const v = canvas.viewportTransform; v[4] += (c.x - (lastCenter?.x||c.x)); v[5] += (c.y - (lastCenter?.y||c.y));
            canvas.requestRenderAll();
            lastDist = d; lastCenter = c; state.zoom = newZoom; $('#zoomLevel').value = Math.round(state.zoom*100);
          }
        }, { passive:false });
        target.addEventListener('touchend', ()=>{ t1=t2=null; lastDist=0; lastCenter=null; canvas.selection = (state.currentTool==='select'); }, { passive:true });
      })();

      // Grid & BG
      $('#gridToggle').addEventListener('change', (e) => { state.grid.show = e.target.checked; canvas.requestRenderAll(); });
      $('#snapToggle').addEventListener('change', (e) => { state.grid.snap = e.target.checked; });
      $('#gridSize').addEventListener('change', (e) => { state.grid.size = clamp(Number(e.target.value)||24, 4, 200); canvas.requestRenderAll(); });
      $('#canvasBg').addEventListener('input', (e) => {
        canvas.setBackgroundColor(e.target.value || '#0f0f11', canvas.renderAll.bind(canvas)); markDirty(); pushHistoryDebounced();
      });

      function useTool(kind){
        state.currentTool = kind;
        state.awaitingPlacement = null;
        canvas.isDrawingMode = false;
        canvas.defaultCursor = 'default';
        // selection enabled only in Move tool
        canvas.selection = (kind === 'select');

        setToolActive(kind);

        if (kind === 'select') { /* Move mode */ return; }

        if (kind === 'draw') {
          canvas.isDrawingMode = true;
          // ensure normal pencil brush
          if (!(canvas.freeDrawingBrush instanceof fabric.PencilBrush)) {
            canvas.freeDrawingBrush = new fabric.PencilBrush(canvas);
          }
          canvas.freeDrawingBrush.color = $('#brushColor').value || '#ffffff';
          canvas.freeDrawingBrush.width = Number($('#brushSize').value || 3);
          canvas.defaultCursor = 'crosshair';
          return;
        }

        if (kind === 'text') {
          // text mode uses click to place/edit; show crosshair
          canvas.defaultCursor = 'crosshair';
          return;
        }

        if (kind === 'sticky') {
          // placement handled on next click; show crosshair
          canvas.defaultCursor = 'crosshair';
          return;
        }

        if (kind === 'erase') {
          // Eraser behaves like brush and subtracts content
          canvas.isDrawingMode = true;
          if (fabric.EraserBrush) {
            canvas.freeDrawingBrush = new fabric.EraserBrush(canvas);
            canvas.freeDrawingBrush.width = Number($('#brushSize').value || 12);
          } else {
            // fallback: use pencil brush; path will be converted in path:created
            canvas.freeDrawingBrush = new fabric.PencilBrush(canvas);
            canvas.freeDrawingBrush.color = '#000';
            canvas.freeDrawingBrush.width = Number($('#brushSize').value || 12);
          }
          canvas.defaultCursor = 'crosshair';
          return;
        }
      }

      // start in Move mode
      useTool('select');
      pushHistory();
    }

    /* =============== MODE TOGGLE =============== */
    function setMode(m) {
      state.mode = m;
      if (m==='doc') {
        $('#docPanel').classList.remove('hidden');
        $('#canvasPanel').classList.add('hidden');
        $('#modeDoc').classList.add('bg-white/10');
        $('#modeCanvas').classList.remove('bg-white/10');
        const mb = document.getElementById('mbMode'); if (mb) mb.textContent = 'Doc';
        try { window.ocFitDoc && window.ocFitDoc(); } catch {}
      } else {
        $('#docPanel').classList.add('hidden');
        $('#canvasPanel').classList.remove('hidden');
        $('#modeCanvas').classList.add('bg-white/10');
        $('#modeDoc').classList.remove('bg-white/10');
        state.canvas && state.canvas.requestRenderAll();
        const mb = document.getElementById('mbMode'); if (mb) mb.textContent = 'Canvas';
        // On small screens, present immersive canvas automatically
        if (window.innerWidth <= 1024 && !document.body.classList.contains('fs-canvas-on') && !document.fullscreenElement) {
          document.body.classList.add('fs-canvas-on');
          document.body.classList.add('fs-active');
          const fsBtn = document.getElementById('canvasFullscreen'); if (fsBtn) fsBtn.textContent = 'Exit';
          const fsTB = document.getElementById('fsToolbarExit'); if (fsTB) fsTB.textContent = 'Exit';
        }
      }
    }

    /* =============== SNAPSHOTS / SAVE / LOAD =============== */
    function getSnapshot() {
      const title = ($('#docTitle').value || '').trim() || 'Untitled note';
      const docHTML = state.quill ? state.quill.root.innerHTML : '';
      let canvasJSON = null, canvasPNG = null, canvasBG = '#0f0f11';
      if (state.canvas) {
        canvasJSON = state.canvas.toJSON(['selectable','evented','stroke','strokeWidth','fill','fontSize','backgroundColor','padding','rx','ry','strokeUniform']);
        try { canvasPNG = state.canvas.toDataURL({ format:'png', multiplier: 2, quality: 1.0 }); } catch { canvasPNG = null; }
        canvasBG = state.canvas.backgroundColor || '#0f0f11';
      }
      return { id: state.id, title, updatedAt: nowISO(), docHTML, canvasJSON, canvasPNG, canvasBG, version: 5 };
    }
    function applySnapshot(snap) {
      state.id = snap.id || uid();
      $('#docTitle').value = snap.title || 'Untitled note';
      if (state.quill) state.quill.root.innerHTML = snap.docHTML || '';
      if (state.canvas && snap.canvasJSON) {
        state.suppressHistory = true;
        state.canvas.loadFromJSON(snap.canvasJSON, () => {
          if (snap.canvasBG) state.canvas.setBackgroundColor(snap.canvasBG, state.canvas.renderAll.bind(state.canvas));
          state.canvas.requestRenderAll();
          // reset history to this state
          try {
            const SAVE_PROPS = ['selectable','evented','stroke','strokeWidth','fill','fontSize','backgroundColor','padding','rx','ry','strokeUniform','globalCompositeOperation','eraser'];
            const initial = { json: state.canvas.toJSON(SAVE_PROPS), bg: state.canvas.backgroundColor || '#0f0f11' };
            state.hist.stack = [initial]; state.hist.idx = 0;
          } catch {}
          state.suppressHistory = false;
        });
      }
      clearDirty();
      refreshSidebarUI();
    }
    function newDocument() {
      if (state.dirty && !confirm('Discard unsaved changes?')) return;
      state.id = uid();
      $('#docTitle').value = 'Untitled note';
      state.quill.root.innerHTML = '';
      if (state.canvas) {
        state.canvas.clear();
        const bg = $('#canvasBg').value || '#0f0f11';
        state.canvas.setBackgroundColor(bg, state.canvas.renderAll.bind(state.canvas));
        // reset canvas history
        try {
          const SAVE_PROPS = ['selectable','evented','stroke','strokeWidth','fill','fontSize','backgroundColor','padding','rx','ry','strokeUniform','globalCompositeOperation','eraser'];
          const initial = { json: state.canvas.toJSON(SAVE_PROPS), bg: state.canvas.backgroundColor || bg };
          state.hist.stack = [initial]; state.hist.idx = 0;
        } catch {}
      }
      clearDirty();
      // Immediately create placeholder entry so it appears in history/sidebar
      const snap = getSnapshot();
      store.upsert(snap);
      refreshHistoryUI();
      refreshSidebarUI();
    }
    function saveDocument() {
      const snap = getSnapshot();
      store.upsert(snap); clearDirty(); flash('Saved'); refreshHistoryUI(); refreshSidebarUI();
    }
    const autoSave = debounce(() => { if (state.dirty) saveDocument(); }, 1500);
    function openFromChooser(){ $('#openFile').click(); }
    function importProject(file) {
      const reader = new FileReader();
      reader.onload = () => {
        try { const data = JSON.parse(reader.result); applySnapshot(data); saveDocument(); }
        catch(e){ alert('Invalid file.'); }
      };
      reader.readAsText(file);
    }

    /* =============== EXPORT BUILDERS =============== */
    function buildStandaloneHTML(snap) {
      const css = `
        meta[charset]{}
        body{ font-family:-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif; color:#111; margin:40px; line-height:1.6; }
        h1{ font-size:28px; margin:0 0 16px; }
        h2{ font-size:20px; margin:24px 0 8px; }
        .doc{ font-size:16px; }
        img.canvas-shot{ max-width:100%; height:auto; margin:16px 0; border:1px solid #e5e5e5; border-radius:8px; }
        .hr{ height:1px; background:#e5e5e5; margin:24px 0; }
        .ql-align-center{text-align:center} .ql-align-right{text-align:right} .ql-align-justify{text-align:justify}
        .ql-indent-1{margin-left:3em} .ql-indent-2{margin-left:6em} .ql-indent-3{margin-left:9em}
      `;
      const docWrapped = `<div class="doc">${snap.docHTML || ''}</div>`;
      const canvasPart = snap.canvasPNG ? `<div class="hr"></div><h2>Canvas</h2><img class="canvas-shot" src="${snap.canvasPNG}" alt="Canvas snapshot" />` : '';
      return `<!DOCTYPE html><html><head><meta charset="utf-8"><title>${escapeHtml(snap.title)}</title><style>${css}</style></head><body>
        <h1>${escapeHtml(snap.title)}</h1>
        ${docWrapped}
        ${canvasPart}
      </body></html>`;
    }

    /* =============== EXPORT ACTIONS =============== */
    async function exportDocx() {
      try {
        const snap = getSnapshot();
        const html = buildStandaloneHTML(snap);

        // html-docx-js returns a Blob already; set explicit MIME just in case
        let blob = window.htmlDocx.asBlob(html, {
          orientation: 'portrait',
          margins: { top: 720, right: 720, bottom: 720, left: 720 } // 0.5" margins in twips
        });

        // Some browsers produce a blob without type; fix it
        if (!blob.type || blob.type === 'application/octet-stream') {
          blob = new Blob([blob], { type: 'application/vnd.openxmlformats-officedocument.wordprocessingml.document' });
        }

        await downloadBlob(blob, safeFileName(snap.title)+'.docx');
        flash('Exported .docx');
      } catch (err) {
        console.error('DOCX export failed', err);
        alert('DOCX export failed. Try disabling content blockers or using a modern browser. Error: ' + (err?.message || err));
      }
    }

    async function exportPDF() {
      const snap = getSnapshot();
      const html = buildStandaloneHTML(snap);

      await html2pdf().set({
        margin: [10,10,10,10],
        filename: safeFileName(snap.title)+'.pdf',
        image: { type: 'jpeg', quality: 0.98 },
        html2canvas: { scale: 2, useCORS: true, backgroundColor: '#ffffff' },
        jsPDF: { unit: 'mm', format: 'letter', orientation: 'portrait' }
      }).from(html).save();

      flash('Exported .pdf');
    }

    function exportHTML() {
      const snap = getSnapshot();
      const html = buildStandaloneHTML(snap);
      const blob = new Blob([html], {type:'text/html;charset=utf-8'});
      downloadBlob(blob, safeFileName(snap.title)+'.html');
      flash('Exported .html');
    }

    function exportJSON() {
      const snap = getSnapshot();
      const blob = new Blob([JSON.stringify(snap,null,2)], {type:'application/json'});
      downloadBlob(blob, safeFileName(snap.title)+'.ocnote');
      flash('Exported .ocnote');
    }

    /* =============== HISTORY UI =============== */
    function openHistory(){ $('#historyDrawer').classList.remove('hidden'); document.body.style.overflow='hidden'; refreshHistoryUI(); }
    function closeHistory(){ $('#historyDrawer').classList.add('hidden'); document.body.style.overflow=''; }
    function refreshHistoryUI() {
      const list = store.loadAll();
      const q = ($('#searchHistory').value || '').toLowerCase();
      const holder = $('#historyList'); holder.innerHTML = '';
      list.filter(item => !q || (item.title?.toLowerCase().includes(q) || (item.docHTML||'').toLowerCase().includes(q)))
          .forEach(item => {
            const row = document.createElement('div');
            row.className = 'glass rounded-xl border p-3 hover:bg-white/10 transition';
            row.style.borderColor = getComputedStyle(document.body).getPropertyValue('--line');
            row.innerHTML = `
              <div class="flex items-center justify-between gap-3">
                <div>
                  <div class="font-medium" style="color:var(--text)">${escapeHtml(item.title||'Untitled')}</div>
                  <div class="text-xs" style="color:var(--muted)">${niceDate(item.updatedAt)}</div>
                </div>
                <div class="flex items-center gap-2">
                  <button class="px-2 py-1 glass-2 hover:bg-white/20 rounded-lg text-xs border" data-open-id="${item.id}" style="border-color:var(--line)">Open</button>
                  <button class="px-2 py-1 glass-2 hover:bg-white/20 rounded-lg text-xs border" data-download-id="${item.id}" style="border-color:var(--line)">Export .ocnote</button>
                </div>
              </div>`;
            holder.appendChild(row);
          });
      holder.querySelectorAll('[data-open-id]').forEach(btn => btn.addEventListener('click', (e) => {
        e.stopPropagation(); const id = btn.getAttribute('data-open-id');
        const item = store.loadAll().find(x => x.id===id);
        if (item){ applySnapshot(item); closeHistory(); }
      }));
      holder.querySelectorAll('[data-download-id]').forEach(btn => btn.addEventListener('click', (e) => {
        e.stopPropagation(); const id = btn.getAttribute('data-download-id');
        const item = store.loadAll().find(x => x.id===id);
        if (item){
          const blob = new Blob([JSON.stringify(item,null,2)], {type:'application/json'});
          downloadBlob(blob, safeFileName(item.title)+'.ocnote');
        }
      }));
    }

    /* =============== SIDEBAR UI (Desktop) =============== */
    function refreshSidebarUI() {
      const list = store.loadAll();
      const q = ($('#sidebarSearch').value || '').toLowerCase();
      const holder = $('#sidebarList'); if (!holder) return; holder.innerHTML = '';
      const currentId = state.id;
      list.filter(item => !q || (item.title?.toLowerCase().includes(q) || (item.docHTML||'').toLowerCase().includes(q)))
          .forEach(item => {
            const row = document.createElement('div');
            row.className = 'note-row glass-2 rounded-xl border p-3 transition';
            row.style.borderColor = getComputedStyle(document.body).getPropertyValue('--line');
            if (item.id === currentId) row.classList.add('active');
            row.innerHTML = `
              <div class="text-sm font-medium truncate" style="color:var(--text)">${escapeHtml(item.title||'Untitled')}</div>
              <div class="text-[11px] mt-0.5" style="color:var(--muted)">${niceDate(item.updatedAt)}</div>
            `;
            row.addEventListener('click', () => { applySnapshot(item); refreshSidebarUI(); });
            holder.appendChild(row);
          });
    }

    /* =============== MENUS / SHORTCUTS =============== */
    function wireMenus() {
      const expBtn = $('#exportBtn'), expMenu = $('#exportMenu');
      const closeMenus = () => { expMenu.classList.add('hidden'); expBtn.setAttribute('aria-expanded','false'); };
      expBtn.addEventListener('click', (e) => { e.stopPropagation(); const open = expMenu.classList.toggle('hidden'); expBtn.setAttribute('aria-expanded', (!open).toString()); });
      document.addEventListener('click', (e) => { if (!expBtn.contains(e.target) && !expMenu.contains(e.target)) closeMenus(); });
      document.addEventListener('keydown', (e) => { if (e.key === 'Escape') closeMenus(); });

      expMenu.querySelectorAll('[data-export]').forEach(btn => btn.addEventListener('click', () => {
        closeMenus();
        const k = btn.getAttribute('data-export');
        if (k==='docx') exportDocx();
        if (k==='pdf')  exportPDF();
        if (k==='html') exportHTML();
        if (k==='json') exportJSON();
      }));

      // History close
      $$('#historyDrawer [data-close-history]').forEach(el => el.addEventListener('click', closeHistory));
      document.addEventListener('keydown', (e) => { if (e.key === 'Escape') closeHistory(); });

      // Sidebar & Drawer new button
      const sbNew = document.getElementById('sbNew'); if (sbNew) sbNew.addEventListener('click', newDocument);
      const drawerNew = document.getElementById('drawerNew'); if (drawerNew) drawerNew.addEventListener('click', newDocument);

      // Drawer export buttons
      $$('#historyDrawer [data-drawer-export]').forEach(btn => btn.addEventListener('click', () => {
        const k = btn.getAttribute('data-drawer-export');
        if (k==='docx') exportDocx();
        if (k==='pdf')  exportPDF();
        if (k==='html') exportHTML();
        if (k==='json') exportJSON();
      }));
    }
    function wireShortcuts() {
      window.addEventListener('keydown', (e) => {
        const isMeta = e.ctrlKey || e.metaKey;
        if (isMeta && e.key.toLowerCase()==='s'){ e.preventDefault(); saveDocument(); }
        if (isMeta && e.key.toLowerCase()==='p'){ e.preventDefault(); exportPDF(); }
      });
    }

    /* =============== BOOT =============== */
    function boot() {
      applyTheme(store.loadTheme() || 'dark');
      initQuill();
      initCanvas();

      // header controls
      $('#modeDoc').addEventListener('click', () => setMode('doc'));
      $('#modeCanvas').addEventListener('click', () => setMode('canvas'));
      $('#newBtn').addEventListener('click', newDocument);
      $('#saveBtn').addEventListener('click', saveDocument);

      $('#openBtn').addEventListener('click', openFromChooser);
      $('#openFile').addEventListener('change', (e) => { const f = e.target.files?.[0]; if (f) importProject(f); e.target.value=''; });

      // history
      const menuBtn = document.getElementById('menuBtn');
      if (menuBtn) menuBtn.addEventListener('click', openHistory);
      $('#searchHistory').addEventListener('input', debounce(refreshHistoryUI, 120));
      const sbs = document.getElementById('sidebarSearch');
      if (sbs) sbs.addEventListener('input', debounce(refreshSidebarUI, 120));

      // title dirty tracking
      const titleEl = $('#docTitle');
      titleEl.addEventListener('input', markDirty);
      // Clear placeholder title on focus for quick rename
      titleEl.addEventListener('focus', () => { if (titleEl.value.trim() === 'Untitled note') { titleEl.value = ''; } });

      // theme
      $('#themeBtn').addEventListener('click', toggleTheme);

      // Mobile bar wiring
      const mbNew = document.getElementById('mbNew');
      const mbSave = document.getElementById('mbSave');
      const mbExport = document.getElementById('mbExport');
      const mbMode = document.getElementById('mbMode');
      const mbTheme = document.getElementById('mbTheme');
      if (mbNew) mbNew.addEventListener('click', newDocument);
      if (mbSave) mbSave.addEventListener('click', saveDocument);
      if (mbExport) mbExport.addEventListener('click', (e)=>{ e.stopPropagation(); const b=document.getElementById('exportBtn'); b && b.click(); });
      if (mbMode) mbMode.addEventListener('click', ()=> setMode(state.mode==='doc' ? 'canvas':'doc'));
      if (mbTheme) mbTheme.addEventListener('click', toggleTheme);

      wireMenus(); wireShortcuts();

      // autosave on idle, visibility change, and every 30s as a safety net
      setInterval(()=>{ if (state.dirty) saveDocument(); }, 30000);
      document.addEventListener('visibilitychange', () => { if (document.visibilityState === 'hidden' && state.dirty) { try { const snap = getSnapshot(); store.upsert(snap); clearDirty(); } catch {} } });
      window.addEventListener('beforeunload', () => { if (state.dirty) { try { const snap = getSnapshot(); store.upsert(snap); } catch {} } });

      setMode('doc');
      refreshHistoryUI();
      refreshSidebarUI();

      // measure header height to position sidebar
      const header = document.querySelector('header');
      if (header) document.documentElement.style.setProperty('--topbar-h', header.offsetHeight + 'px');
      // sidebar open/close state
      state.sidebarOpen = store.loadSidebarOpen();
      const applySidebarPadding = () => {
        const wide = window.innerWidth >= 1024;
        if (wide && state.sidebarOpen) {
          document.body.classList.add('with-sidebar');
          document.body.classList.remove('sidebar-collapsed');
        } else {
          document.body.classList.remove('with-sidebar');
          document.body.classList.add('sidebar-collapsed');
        }
      };
      applySidebarPadding();
      window.addEventListener('resize', debounce(() => { applySidebarPadding(); fitDoc(); }, 120));

      // sidebar toggle (desktop)
      const sbToggle = document.getElementById('toggleSidebar');
      if (sbToggle) sbToggle.addEventListener('click', () => { state.sidebarOpen = !state.sidebarOpen; store.saveSidebarOpen(state.sidebarOpen); applySidebarPadding(); fitDoc(); });

      // Ensure page fits viewport like Word (always one 8.5x11 on screen)
      function fitDoc(){
        const wrap = document.getElementById('pageWrap'); if (!wrap) return;
        const page = document.getElementById('page'); if (!page) return;
        const headerEl = document.querySelector('header');
        const tb = document.getElementById('quillToolbar');
        const titleSec = document.getElementById('docTitle')?.closest('section');
        const hH = headerEl?.offsetHeight || 0;
        const tH = tb?.offsetHeight || 0;
        const titleH = titleSec?.offsetHeight || 0;
        const availH = Math.max(400, window.innerHeight - hH - tH - titleH - 48);
        const availW = Math.max(320, wrap.clientWidth - 24);
        const scale = Math.min(availW / 816, availH / 1056, 1);
        state.docScale = scale;
        page.style.transform = `scale(${scale})`;
        wrap.style.minHeight = Math.ceil(1056 * scale + 24) + 'px';
      }
      fitDoc();
      window.ocFitDoc = fitDoc;
      window.addEventListener('resize', debounce(fitDoc, 150));

      // Register service worker (PWA)
      if ('serviceWorker' in navigator) {
        try { navigator.serviceWorker.register('./sw.js'); } catch(e) { console.warn('SW registration failed', e); }
      }
    }

    document.addEventListener('DOMContentLoaded', boot);
  </script>
  <!-- Mobile bottom bar -->
  <nav class="mobile-bar fixed left-1/2 -translate-x-1/2 bottom-3 safe-pad-bottom px-2 py-1.5 glass border rounded-2xl shadow-lg flex items-center gap-1 z-[70]" style="border-color:var(--line); display:none">
    <button id="mbNew" class="px-2 py-1.5 text-sm rounded-xl hover:bg-white/10 flex items-center" aria-label="New">
      <span class="plus-glow" aria-hidden="true"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round"><path d="M12 5v14M5 12h14"/></svg></span>
    </button>
    <button id="mbMode" class="px-3 py-2 text-sm rounded-xl hover:bg-white/10" aria-label="Toggle mode">Doc</button>
    <button id="mbTheme" class="px-3 py-2 text-sm rounded-xl hover:bg-white/10" aria-label="Toggle theme">â˜€ï¸Ž/ðŸŒ™</button>
  </nav>
</body>
</html>
